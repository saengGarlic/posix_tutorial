/*
1. 라즈베리파이와 컴퓨터를 연결하여 ssh 구동 가능
2. 첨부의 파일을 읽어서 다음의 프로그램을 구현하시오.

나이별, 이름별, 지역별(zip code) 분포를 구하시오.

순서는 숫자, 알파벳 오름차순으로 정리

나이 : 10 ~ 89
zip code : 001 ~ 015

---------------------------
파일 내용

24,ABC,KS003

32,BCD,KS005

...

----------------------------

 

결과 출력 예제


전체 데이터 갯수 1,000,000개 중 이름은 xx,xxx개
나이:

10 ~ 19 : 3,423명

20 ~ 29 : 5,333명

..

80 ~ 89 : xxx명

 

Zip code

KS001: xxxxx명

KS002: xxxxx명

...

KS015: xxxxx명
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
//#include <pthread.h>



typedef struct Row{
	int age;
	char name[3];
	char ziphead[2];
	int zip;
}Row;

void test(Row *arr);
void merge(Row *arr, int s, int e, int m);
void mergesort(Row *arr, int s, int e);


int main()
{
	Row *row_arr, *temp;
	
	int lineNum, i;
	char c;
	FILE *fp;
	
	
	fp = fopen("data.txt", "r");
	
	if(fp != NULL) printf("file import success\n");
	
	lineNum = 0;
	while((c = fgetc(fp))!=EOF){
		if(c=='\n') lineNum++;
	}
	printf("total line:%d\n",lineNum);
	
	row_arr = (Row *)malloc(sizeof(Row)*lineNum);
	temp = row_arr;
	if(row_arr != NULL) printf("memory allocation success\n");
	
	rewind(fp);
	
	if(fp != NULL) printf("file import success\n");
	
	i = 0;
	while(i<lineNum){
		fscanf(fp, "%2d,%3s,%2s%3d", &(temp+i)->age, &(temp+i)->name, &(temp+i)->ziphead, &(temp+i)->zip);
		if(i < 50) printf("%d %d,%s,%s%3d\n", i, (temp+i)->age, (temp+i)->name, (temp+i)->ziphead, (temp+i)->zip);
		i++;
	}
	fclose(fp);
	
	test(row_arr);
	for(i=0; i<10; i++){
		
		printf("%d %d,%s,%s%3d\n", i, (row_arr+i)->age, (row_arr+i)->name, (row_arr+i)->ziphead, (row_arr+i)->zip);
	}
	//mergesort(row_arr, 0, i);
	
	
	fp = fopen("output.txt", "w");
	i = 0;
	while(i == lineNum){
		fprintf(fp, "%2d,%3s,%2s%3d", (temp+i)->age, (temp+i)->name, (temp+i)->ziphead, (temp+i)->zip);
		i++;
	}
	fclose(fp);
	
}

//s: start e:end 
void test(Row *arr){
	int i = 0;
	for(i; i<10; i++){
		printf("%d %d,%s,%s%3d\n", i, (arr+i)->age, (arr+i)->name, (arr+i)->ziphead, (arr+i)->zip);
	}
	for(i=0; i<10; i++){
		(arr+9-i)->age = (arr+i)->age;
		&(arr+9-i)->name = "fck";
		&(arr+9-i)->ziphead = "UU";
		(arr+9-i)->zip = (arr+i)->zip;
		printf("%d %d,%s,%s%3d\n", i, (arr+i)->age, (arr+i)->name, (arr+i)->ziphead, (arr+i)->zip);
	}
	
	
}
void merge(Row *arr, int s, int e, int m){
	
	int i = s;
	int j = m + 1;
	int n = 0;
	int size = e - s + 1;
	Row temp[size];
	
	while(i <= m && j <= e){
		if((arr+i)->age == (arr+j)->age){
			//printf("%d || %d\n", (arr+i)->age, (arr+j)->age);
			if(strcmp((arr+i)->name, (arr+j)->name) == 0){				
				if((arr+i)->zip < (arr+j)->zip){
					temp[n] = arr[i];
					i++;
					n++;
				}
				else{
					temp[n] = arr[i];
					j++;
					n++;
				}
			}
		
			
			else if(strcmp(arr[i].name, arr[j].name) < 0){
				temp[n] = arr[i];
				i++;
				n++;
			}
			else{
				temp[n] = arr[i];
				j++;
				n++;
			}
		}
			
		else if(arr[i].age < arr[j].age){
			temp[n] = arr[i];
			i++;
			n++;
		}
		else{
			temp[n] = arr[i];
			j++;
			n++;
		}
	}
	
	//원래배열에 집어넣기
	n = 0;
	for(i = s; i <= e; i++){
		arr[i] = temp[n];
		n++;
	}
	
		
}
void mergesort(Row *arr, int s, int e){
	if(s<e){
		int m = (s+e)/2;
		
		mergesort(arr, s, m);
		mergesort(arr, m+1, e);
		
		merge(arr, s, e, m);
	}
}


